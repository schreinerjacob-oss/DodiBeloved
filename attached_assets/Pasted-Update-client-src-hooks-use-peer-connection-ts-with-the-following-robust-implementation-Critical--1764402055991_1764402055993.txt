Update client/src/hooks/use-peer-connection.ts with the following robust implementation. 

Critical Requirements:
1. Use global singleton variables (globalPeer, globalConn) outside the component to persist the connection when navigating between pages.
2. Implement auto-reconnection logic if the peer disconnects.
3. Ensure the 'p2p-message' event is dispatched when data is received so other components can react.

Use this exact code:

import { useEffect, useState, useCallback } from 'react';
import { useDodi } from '@/contexts/DodiContext';
import type { SyncMessage } from '@/types';
import Peer, { type DataConnection } from 'peerjs';

interface PeerConnectionState {
  connected: boolean;
  error: string | null;
  peerId: string | null;
  isReconnecting: boolean;
}

interface UsePeerConnectionReturn {
  state: PeerConnectionState;
  send: (message: SyncMessage) => void;
  reconnect: () => void;
}

// Global singleton variables to persist across renders
let globalPeer: Peer | null = null;
let globalConn: DataConnection | null = null;

export function usePeerConnection(): UsePeerConnectionReturn {
  const { userId, partnerId, pairingStatus } = useDodi();
  const [state, setState] = useState<PeerConnectionState>({
    connected: false,
    error: null,
    peerId: null,
    isReconnecting: false,
  });

  const updateState = useCallback(() => {
    setState({
      connected: !!globalConn && globalConn.open,
      error: null,
      peerId: globalPeer?.id || null,
      isReconnecting: globalPeer ? globalPeer.disconnected : false,
    });
  }, []);

  // 1. ESTABLISH PEER
  useEffect(() => {
    if (pairingStatus !== 'connected' || !userId) return;
    
    if (globalPeer && !globalPeer.destroyed && globalPeer.id === userId) {
      if (globalPeer.disconnected) globalPeer.reconnect();
      return;
    }

    if (globalPeer) globalPeer.destroy();

    console.log('ðŸŒ Starting P2P Network Service for:', userId);
    
    const peer = new Peer(userId, {
      host: '0.peerjs.com',
      port: 443,
      secure: true,
      debug: 1,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:global.stun.twilio.com:3478' }
        ]
      }
    });

    globalPeer = peer;

    peer.on('open', (id) => {
      console.log('âœ… My Peer ID is active:', id);
      updateState();
      if (partnerId) connectToPartner(partnerId);
    });

    peer.on('error', (err) => {
      console.error('PeerJS Error:', err);
      setState(prev => ({ ...prev, error: err.type === 'unavailable-id' ? 'Connection conflict' : err.message }));
    });

    peer.on('disconnected', () => {
      console.log('ðŸ“¡ Disconnected from signaling server. Attempting reconnect...');
      updateState();
      peer.reconnect();
    });

    peer.on('connection', (conn) => {
      console.log('ðŸ“ž Incoming connection from:', conn.peer);
      if (conn.peer === partnerId) {
        setupConnection(conn);
      } else {
        console.warn('ðŸš« Blocked unknown peer:', conn.peer);
        conn.close();
      }
    });

    return () => {
      // Intentionally DO NOT destroy peer on unmount to keep connection alive
    };
  }, [userId, partnerId, pairingStatus]);

  // 2. CONNECT TO PARTNER
  const connectToPartner = (targetId: string) => {
    if (!globalPeer || globalPeer.destroyed) return;
    if (globalConn && globalConn.open && globalConn.peer === targetId) return;

    console.log('ðŸ”— Dialing partner:', targetId);
    const conn = globalPeer.connect(targetId, {
      reliable: true,
      serialization: 'json',
    });
    setupConnection(conn);
  };

  // 3. SETUP DATA PIPE
  const setupConnection = (conn: DataConnection) => {
    if (globalConn && globalConn.open && globalConn.peer === conn.peer && globalConn !== conn) {
      conn.close();
      return;
    }

    globalConn = conn;

    conn.on('open', () => {
      console.log('âœ¨ SECURE PIPE ESTABLISHED with:', conn.peer);
      updateState();
      conn.send({ type: 'ping', timestamp: Date.now() });
    });

    conn.on('data', (data: any) => {
      console.log('ðŸ“© INCOMING:', data.type || 'unknown');
      if (data.type === 'ping') return;
      window.dispatchEvent(new CustomEvent('p2p-message', { detail: data }));
    });

    conn.on('close', () => {
      console.log('XY Connection lost');
      if (globalConn === conn) globalConn = null;
      updateState();
      if (partnerId) setTimeout(() => connectToPartner(partnerId), 3000);
    });

    conn.on('error', (err) => {
      console.error('Connection Error:', err);
      if (globalConn === conn) globalConn = null;
      updateState();
    });
  };

  const send = useCallback((message: SyncMessage) => {
    if (globalConn && globalConn.open) {
      globalConn.send(message);
      console.log('ðŸ“¤ Sent:', message.type);
    } else {
      console.warn('âš ï¸ Failed to send: Pipe broken');
      if (partnerId) connectToPartner(partnerId);
    }
  }, [partnerId]);

  const reconnect = useCallback(() => {
    if (globalPeer && globalPeer.disconnected) {
      globalPeer.reconnect();
    } else if (partnerId) {
      connectToPartner(partnerId);
    }
  }, [partnerId]);

  useEffect(() => {
    const interval = setInterval(() => {
      updateState();
      if (!globalConn || !globalConn.open) {
        if (partnerId) connectToPartner(partnerId);
      }
    }, 5000);
    return () => clearInterval(interval);
  }, [partnerId, updateState]);

  return { state, send, reconnect };
}
